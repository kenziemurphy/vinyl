<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Test</title>
    <style>
        body {
            margin: 0;
            background-color: #141517;
            overflow: hidden;
            font-family: Helvetica, sans-serif
        }

        .pulse:hover {
            animation: pulse;
            animation-iteration-count: infinite;
        }

        .song .dot {
            stroke: #fff;
            fill: #fff;
            stroke-width: 5;
            stroke-opacity: 0.6;
            fill-opacity: 0;
        }

        .song .song-label {
            opacity: 0;
            text-anchor: middle;
            z-index: 100;
        }

        .song:hover .song-label {
            opacity: 1;
        }

        text {
            font-size: 10pt;
        }

        .label {
            text-anchor: middle;
            alignment-baseline: central;
            opacity: 0.3;
        }

        .label-align-bottom {
            text-anchor: middle;
            alignment-baseline: bottom;
        }

        .label-align-top {
            text-anchor: middle;
            alignment-baseline: top;
        }

        .grid-line {
            fill-opacity: 0;
            stroke-opacity: 0.2;
            stroke: #ffffff;
        }

        .grid-line-clear {
            fill-opacity: 0;
            stroke-opacity: 1;
            stroke-width: 3;
            stroke: #ffffff;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            1% {
                transform: scale(1.2);
            }
            80% {
                transform: scale(1);
            }
            100% {
                transform: scale(1);
            }
        }
    </style>
</head>
<body>
    <div class="vis"><svg width="800" height="600"></svg></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.12.0/d3.min.js"></script>
    <script>
        // config
        const RADIAL_MAPPING = 'tempo';
        const DOT_RADIUS_MAPPING = 'popularity';

        const NUM_RADIAL_GRID_LINES = 5;
        const ALL_KEYS = [
            'Cm', 'C♯m/D♭m', 'Dm', 'D♯m/E♭', 'Em', 'Fm', 'F♯m/G♭m', 'Gm', 'G♯m/A♭m', 'Am', 'A♯m/B♭m', 'Bm',
            'C', 'C♯/D♭', 'D', 'D♯/E♭', 'E', 'F', 'F♯/G♭', 'G', 'G♯/A♭', 'A', 'A♯/B♭', 'B',
        ];
        const NUM_KEYS = ALL_KEYS.length;

        // const ALL_KEYS = [
        //     'Cm', 'C', 'C♯m/D♭m', 'C♯/D♭', 'Dm', 'D', 'D♯m/E♭m', 'Dm/E♭', 'Em', 'E', 'Fm', 'F', 'F♯m/G♭m', 'F♯/G♭', 'Gm', 'G', 'G♯m/A♭m', 'G♯/A♭', 'Am', 'A', 'A♯m/B♭m', 'A♯/B♭', 'Bm', 'B'
        // ];
  
        // computed consts
        const ANGLE_TILT = Math.PI * 2 / NUM_KEYS / 2;    // can't draw the "0" upright, we want the major/minor line to be completely horizontal
        const ALL_KEYS_RANGE = d3.range(0, NUM_KEYS, 1);
        const SCALE_ANGLE = d3.scaleOrdinal()
            .domain(ALL_KEYS)
            .range(d3.range(
                ANGLE_TILT, 
                Math.PI * 2 + ANGLE_TILT,
                Math.PI * 2 / ALL_KEYS.length
            ));

        // screen-dependent computed consts, will update when screen size is changed for responsive vis
        var W, H;
        var MIN_RADIAL_DIST;
        var MAX_RADIAL_DIST;

        function recomputeScreenConsts() {
            H = parseInt(svg.style("height"), 10);
            W = parseInt(svg.style("width"), 10);
            
            MIN_RADIAL_DIST = Math.min(W, H) / 6;
            MAX_RADIAL_DIST = Math.min(W, H) / 2 - 70;
        }

        // data-dependent computed consts, will update when data is loaded
        var SCALE_RADIAL = x => x;
        var SCALE_DOT_RADIUS = x => x;
        var SCALE_DOT_COLOR = x => x;

        function recomputeDataConsts () {
            SCALE_RADIAL = d3.scaleLinear()
                .domain(d3.extent(data, d => d[RADIAL_MAPPING]))
                // .domain([0, 1])
                .range([MIN_RADIAL_DIST, MAX_RADIAL_DIST]);

            console.log(d3.extent(data, d => d[DOT_RADIUS_MAPPING]));
            SCALE_DOT_RADIUS = d3.scalePow()
                .exponent(1)
                .domain(d3.extent(data, d => d[DOT_RADIUS_MAPPING]))
                // .domain([0, 100])
                .range([2, 25]);

            function onlyUnique(value, index, self) { 
                return self.indexOf(value) === index;
            }
            SCALE_DOT_COLOR = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(data.map(x => x.album.name).filter(onlyUnique));
        }



        // core global stuffs
        var data = [];
        var svg;
        var fileReady = false;

        initialize();

        window.addEventListener("resize", function () {
            initialize();
            
            if (fileReady) {
                d3.selectAll("svg > *").remove();
                draw(data);
            }
        });

        d3.json('temp.json').then(function (data) {
            console.log(data)
            console.log(data.items.map(d=>d.uri.replace('spotify:track:', '')).join(','));
        });
        Promise.all([
            // d3.json('../../data/Spotify.json'),
            // d3.json('../../data/Spotify_trackinfo.json'),
            // d3.json('slotmachine.json'),
            // d3.json('slotmachine_trackinfo.json'),
            d3.json('radiohead.json'),
            d3.json('radiohead_trackinfo.json'),
        ]).then(function (loadedData) {
            data = preprocessData(loadedData); 
            fileReady = true;
            console.log(data);

            recomputeDataConsts();
            
            draw(data);
        });


        
        function initialize () {
            svg = d3.select('.vis svg');

            svg.style("height", window.innerHeight);
            svg.style("width", window.innerWidth);

            recomputeScreenConsts();
            if (fileReady) {
                recomputeDataConsts();
            }
        }

        function draw (data) {
            drawGrid();
            drawDataPoints();
        }

        


        function preprocessData (files) {
            // outer join
            // var filesConcat = files[0].concat(files[1].tracks);
            // var data = d3.nest()
            //     .key(d => d.uri)
            //     .entries(filesConcat);
            // data = data.map(function (d) {
            //     return {...d.values[0], ...d.values[1]};
            // })
            // return data;

            // inner join
            return arrayJoin(files[0], files[1].tracks, 'uri');

        }

        function drawGrid () {
            var minRadialData = d3.min(data, d => d[RADIAL_MAPPING]);
            var maxRadialData = d3.max(data, d => d[RADIAL_MAPPING]); 
            var radialGridGap = (maxRadialData - minRadialData) / NUM_RADIAL_GRID_LINES;
            var radialGridInterval = d3.range(minRadialData, maxRadialData, radialGridGap);
            var angularGridInterval = d3.range(0, NUM_KEYS, 1);

            radialGridInterval.push(maxRadialData);

            var gridG = svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(${W / 2}, ${H / 2})`);

            var radialGrid = gridG.selectAll('circle.grid-line')
                .data(radialGridInterval)
                .enter()
                .append('circle')
                .attr('class', 'grid-line')
                .attr('r', d => SCALE_RADIAL(d))
                .attr('fill-opacity', '0')
                .attr('stroke-opacity', '0.2')
                .attr('stroke', '#ffffff')

            var angleGrid = gridG.selectAll('line.grid-line')
                .data(ALL_KEYS)
                .enter()
                .append('line')
                .attr('class', 'grid-line')
                .attr('x1', d => angleDistanceToXy(SCALE_ANGLE(d), MIN_RADIAL_DIST)[0])
                .attr('y1', d => angleDistanceToXy(SCALE_ANGLE(d), MIN_RADIAL_DIST)[1])
                .attr('x2', d => angleDistanceToXy(SCALE_ANGLE(d), MAX_RADIAL_DIST)[0])
                .attr('y2', d => angleDistanceToXy(SCALE_ANGLE(d), MAX_RADIAL_DIST)[1])

            var angleLabel = gridG.selectAll('text.key.label')
                .data(ALL_KEYS)
                .enter()
                .append('text')
                .attr('class', 'key label')
                .text(d => d)
                .attr('x', d => angleDistanceToXy(SCALE_ANGLE(d), MAX_RADIAL_DIST + 20)[0])
                .attr('y', d => angleDistanceToXy(SCALE_ANGLE(d), MAX_RADIAL_DIST + 20)[1])
                .attr('fill', '#ffffff')

            var radialLabelTop = gridG.selectAll('text.tempo.label.top')
                .data(radialGridInterval)
                .enter()
                .append('text')
                .attr('class', 'tempo label top')
                .text(d => round(d, 1))
                .attr('y', d => -SCALE_RADIAL(d))
                .attr('fill', '#ffffff')

            var radialTextLabelInnerTop = gridG.append('text')
                .attr('class', 'tempo label')
                .text(RADIAL_MAPPING.toUpperCase())
                .attr('y', -MIN_RADIAL_DIST + 30)
                .attr('font-weight', 'bold')
                .style('opacity', 0.7)
                .attr('fill', '#ffffff')

            var radialTextLabelOuterTop = gridG.append('text')
                .attr('class', 'tempo label')
                .text(RADIAL_MAPPING.toUpperCase())
                .attr('y', -MAX_RADIAL_DIST - 30)
                .attr('font-weight', 'bold')
                .style('opacity', 0.7)
                .attr('fill', '#ffffff')

            var radialLabelBottom = gridG.selectAll('text.tempo.label.bottom')
                .data(radialGridInterval)
                .enter()
                .append('text')
                .attr('class', 'tempo label bottom')
                .text(d => round(d, 1))
                .attr('y', d => SCALE_RADIAL(d))
                .attr('fill', '#ffffff')

            var radialTextLabelInnerBottom = gridG.append('text')
                .attr('class', 'tempo label')
                .text(RADIAL_MAPPING.toUpperCase())
                .attr('y', MIN_RADIAL_DIST - 30)
                .attr('font-weight', 'bold')
                .style('opacity', 0.7)
                .attr('fill', '#ffffff')

            var radialTextLabelOuterBottom = gridG.append('text')
                .attr('class', 'tempo label')
                .text(RADIAL_MAPPING.toUpperCase())
                .attr('y', MAX_RADIAL_DIST + 30)
                .attr('font-weight', 'bold')
                .style('opacity', 0.7)
                .attr('fill', '#ffffff')

            // major/minor line
            // FIXME hardcoding
            var majorMinorLabelOffset = 60;
            var majorMinorLineLeft = gridG.append('line')
                .attr('class', 'grid-line-clear')
                .attr('x1', -MIN_RADIAL_DIST)
                .attr('y1', 0)
                .attr('x2', -MAX_RADIAL_DIST - majorMinorLabelOffset)
                .attr('y2', 0)

            var majorMinorLinRight = gridG.append('line')
                .attr('class', 'grid-line-clear')
                .attr('x1', MIN_RADIAL_DIST)
                .attr('y1', 0)
                .attr('x2', MAX_RADIAL_DIST + majorMinorLabelOffset)
                .attr('y2', 0)

            var majorLabelLeft = gridG.append('text')
                .text('MAJOR')
                .attr('fill', '#ffffff')
                .attr('x', -MAX_RADIAL_DIST - majorMinorLabelOffset)
                .attr('y', -7)
                .attr('aligment-baseline', 'baseline')
                .attr('text-anchor', 'start')
            
            var minorLabelLeft = gridG.append('text')
                .text('MINOR')
                .attr('fill', '#ffffff')
                .attr('x', -MAX_RADIAL_DIST - majorMinorLabelOffset)
                .attr('y', 7)
                .attr('alignment-baseline', 'hanging')
                .attr('text-anchor', 'start')
            
            var majorLabelRight = gridG.append('text')
                .text('MAJOR')
                .attr('fill', '#ffffff')
                .attr('x', MAX_RADIAL_DIST + majorMinorLabelOffset)
                .attr('y', -7)
                .attr('aligment-baseline', 'baseline')
                .attr('text-anchor', 'end')
            
            var minorLabelRight = gridG.append('text')
                .text('MINOR')
                .attr('fill', '#ffffff')
                .attr('x', MAX_RADIAL_DIST + majorMinorLabelOffset)
                .attr('y', 7)
                .attr('alignment-baseline', 'hanging')
                .attr('text-anchor', 'end')
        }

        function drawDataPoints () {
            var songG = svg.selectAll('g.song')
                .data(data)
                .enter()
                .append('g')
                .attr('class', 'song')
                .attr('transform', function (d) {
                    let coord = angleDistanceToXy(SCALE_ANGLE(getKeyFromKeyId(d.key, d.mode)), SCALE_RADIAL(d[RADIAL_MAPPING]));
                    let x = W / 2 + coord[0];
                    let y = H / 2 + coord[1];
                    return `translate(${x}, ${y})`
                });


            var defs = songG.append('svg:defs');
            
            defs.append('svg:pattern')
                .attr('id', d => `image${d.id}`)
                .attr("width", d => 2 * SCALE_DOT_RADIUS(d[DOT_RADIUS_MAPPING]))
                .attr("height", d => 2 * SCALE_DOT_RADIUS(d[DOT_RADIUS_MAPPING]))
                .attr("x", d => -SCALE_DOT_RADIUS(d[DOT_RADIUS_MAPPING]))
                .attr("y", d => -SCALE_DOT_RADIUS(d[DOT_RADIUS_MAPPING]))
                .attr("patternUnits", "userSpaceOnUse")
                .append("svg:image")
                .attr("xlink:href", d => d.album.images[2].url)
                // .attr("xlink:href", 'https://upload.wikimedia.org/wikipedia/en/8/8b/Radiohead.bends.albumart.jpg')
                .attr("width", d => 2 * SCALE_DOT_RADIUS(d[DOT_RADIUS_MAPPING]))
                .attr("height", d => 2 * SCALE_DOT_RADIUS(d[DOT_RADIUS_MAPPING]));

            var dots = songG
                .append('circle')
                .attr('class', 'dot pulse')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', d => SCALE_DOT_RADIUS(d[DOT_RADIUS_MAPPING]))
                .style('animation-duration', d => `${60 / d.tempo}s`)
                .style('stroke-opacity', 1)
                .style('stroke-width', 2.5)
                .style('fill-opacity', 1)
                .style('fill', '#fff')
                .style('fill', d => `url(#image${d.id})`)
                // .style('stroke', d => SCALE_DOT_COLOR(d.artists[0].name))
                // .style('fill', d => SCALE_DOT_COLOR(d.artists[0].name));

            


            var songLabels = songG
                .append('text')
                .text(d => `${d.artists ? d.artists.map(a => a.name) : 'Unknown'} - ${d.name}`)
                .attr('class', 'song-label')
                .attr('x', 0)
                .attr('y', -30)
                .attr('fill', d => '#ffffff')
        }



        // helpers

        function angleDistanceToXy (angle, distance) {
            return [
                Math.cos(angle) * distance,
                Math.sin(angle) * distance
            ]
        }

        function getKeyFromKeyId (key, mode = false) {
            if (mode === false) {
                mode = Math.ceil(key / 12);
                key = key % 12;
            }

            return ALL_KEYS[key + mode * 12];
            // return ALL_KEYS[key * 2 + mode];
        }

        function arrayJoin (a, b, key) {
            var bKeys = b.map(y => y[key]);
            var abJoined = a.map(function (x) {
                var bIndex = bKeys.indexOf(x[key])
                if (bIndex >= 0) {
                    // console.log(x[key], b[bIndex].name);
                    return {...x, ...b[bIndex]};
                } else {
                    return false;
                }
            });
            
            return abJoined.filter(x => x !== false);
        }

        function round(value, decimals) {
           return Number(Math.round(value+'e'+decimals)+'e-'+decimals);
        }
    </script>
</body>
</html>